/* tslint:disable */
/* eslint-disable */
/*
Core API

Front is a customer operations platform that enables support, sales, and account management teams to deliver exceptional service at scale. Front streamlines customer communication by combining the efficiency of a help desk and the familiarity of email, with automated workflows and real-time collaboration behind the scenes.

With Front, teams can centralize messages across channels, route them to the right person, and unlock visibility and insights across all of their customer operations. More than 8000 businesses use Front to drive operational efficiency that prevents churn, improves retention, and propels customer growth.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { CustomMessage } from '../models';
// @ts-ignore
import { CustomMessageMetadata } from '../models';
// @ts-ignore
import { CustomMessageSender } from '../models';
// @ts-ignore
import { ImportMessage } from '../models';
// @ts-ignore
import { ImportMessageMetadata } from '../models';
// @ts-ignore
import { ImportMessageSender } from '../models';
// @ts-ignore
import { MessagesGetMessageSeenStatusResponse } from '../models';
// @ts-ignore
import { MessagesReceiveCustomMessageResponse } from '../models';
// @ts-ignore
import { OutboundMessage } from '../models';
// @ts-ignore
import { OutboundMessageOptions } from '../models';
// @ts-ignore
import { OutboundReplyMessage } from '../models';
// @ts-ignore
import { OutboundReplyMessageOptions } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Reply to a conversation by sending a message and appending it to the conversation.
         * @summary Create message reply
         * @param {string} conversationId The conversation ID
         * @param {OutboundReplyMessage} [outboundReplyMessage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageReply: async (conversationId: string, outboundReplyMessage?: OutboundReplyMessage, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('createMessageReply', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}/messages`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: outboundReplyMessage,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}/messages',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(outboundReplyMessage, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a new message from a channel. This is one of the ways to create a new [conversation](https://dev.frontapp.com/reference/conversations#creating-a-new-conversation). The new conversation will support both messages and comments (discussions).
         * @summary Create message
         * @param {string} channelId The sending channel ID. Alternatively, you can supply the sending channel address as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
         * @param {OutboundMessage} [outboundMessage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewMessage: async (channelId: string, outboundMessage?: OutboundMessage, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('createNewMessage', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/messages`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId !== undefined ? channelId : `-channel_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: outboundMessage,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/channels/{channel_id}/messages',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(outboundMessage, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a message.  > ℹ️ The HTTP Header `Accept` can be used to request the message in a different format. > By default, Front will return the documented JSON response. By requesting `message/rfc822`, the response will contain the message in the EML format (for email messages only). 
         * @summary Get message
         * @param {string} messageId The message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById: async (messageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getMessageById', 'messageId', messageId)
            const localVarPath = `/messages/{message_id}`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId !== undefined ? messageId : `-message_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messages/{message_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the seen receipts for the given message. If no seen-by information is available, there will be a single entry for the first time the message was seen by any recipient. If seen-by information is available, there will be an entry for each recipient who has seen the message.
         * @summary Get message seen status
         * @param {string} messageId The message ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageSeenStatus: async (messageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('getMessageSeenStatus', 'messageId', messageId)
            const localVarPath = `/messages/{message_id}/seen`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId !== undefined ? messageId : `-message_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messages/{message_id}/seen',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import a new message in an inbox.
         * @summary Import message
         * @param {string} inboxId The Inbox ID
         * @param {ImportMessage} [importMessage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importNewInboxMessage: async (inboxId: string, importMessage?: ImportMessage, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inboxId' is not null or undefined
            assertParamExists('importNewInboxMessage', 'inboxId', inboxId)
            const localVarPath = `/inboxes/{inbox_id}/imported_messages`
                .replace(`{${"inbox_id"}}`, encodeURIComponent(String(inboxId !== undefined ? inboxId : `-inbox_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: importMessage,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/inboxes/{inbox_id}/imported_messages',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(importMessage, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark an outbound message from Front as seen. Note, the message seen route should only be called in response to an actual end-user\'s message-seen action. In accordance with this behavior, the route is rate limited to 10 requests per hour. The request body should send an empty object.
         * @summary Mark message seen
         * @param {string} messageId The message ID
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markMessageSeen: async (messageId: string, body?: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('markMessageSeen', 'messageId', messageId)
            const localVarPath = `/messages/{message_id}/seen`
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId !== undefined ? messageId : `-message_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: body,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/messages/{message_id}/seen',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receive a custom message in Front. This endpoint is available for custom channels **ONLY**.
         * @summary Receive custom messages
         * @param {string} channelId The channel ID. Alternatively, you can supply the channel address as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
         * @param {CustomMessage} [customMessage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveCustomMessage: async (channelId: string, customMessage?: CustomMessage, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            assertParamExists('receiveCustomMessage', 'channelId', channelId)
            const localVarPath = `/channels/{channel_id}/incoming_messages`
                .replace(`{${"channel_id"}}`, encodeURIComponent(String(channelId !== undefined ? channelId : `-channel_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: customMessage,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/channels/{channel_id}/incoming_messages',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(customMessage, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Reply to a conversation by sending a message and appending it to the conversation.
         * @summary Create message reply
         * @param {MessagesApiCreateMessageReplyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessageReply(requestParameters: MessagesApiCreateMessageReplyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const outboundReplyMessage: OutboundReplyMessage = {
                to: requestParameters.to,
                cc: requestParameters.cc,
                bcc: requestParameters.bcc,
                sender_name: requestParameters.sender_name,
                subject: requestParameters.subject,
                author_id: requestParameters.author_id,
                channel_id: requestParameters.channel_id,
                body: requestParameters.body,
                text: requestParameters.text,
                quote_body: requestParameters.quote_body,
                options: requestParameters.options,
                attachments: requestParameters.attachments,
                signature_id: requestParameters.signature_id,
                should_add_default_signature: requestParameters.should_add_default_signature
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessageReply(requestParameters.conversationId, outboundReplyMessage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send a new message from a channel. This is one of the ways to create a new [conversation](https://dev.frontapp.com/reference/conversations#creating-a-new-conversation). The new conversation will support both messages and comments (discussions).
         * @summary Create message
         * @param {MessagesApiCreateNewMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewMessage(requestParameters: MessagesApiCreateNewMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const outboundMessage: OutboundMessage = {
                to: requestParameters.to,
                cc: requestParameters.cc,
                bcc: requestParameters.bcc,
                sender_name: requestParameters.sender_name,
                subject: requestParameters.subject,
                author_id: requestParameters.author_id,
                body: requestParameters.body,
                text: requestParameters.text,
                options: requestParameters.options,
                attachments: requestParameters.attachments,
                signature_id: requestParameters.signature_id,
                should_add_default_signature: requestParameters.should_add_default_signature
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewMessage(requestParameters.channelId, outboundMessage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a message.  > ℹ️ The HTTP Header `Accept` can be used to request the message in a different format. > By default, Front will return the documented JSON response. By requesting `message/rfc822`, the response will contain the message in the EML format (for email messages only). 
         * @summary Get message
         * @param {MessagesApiGetMessageByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageById(requestParameters: MessagesApiGetMessageByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageById(requestParameters.messageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the seen receipts for the given message. If no seen-by information is available, there will be a single entry for the first time the message was seen by any recipient. If seen-by information is available, there will be an entry for each recipient who has seen the message.
         * @summary Get message seen status
         * @param {MessagesApiGetMessageSeenStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessageSeenStatus(requestParameters: MessagesApiGetMessageSeenStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessagesGetMessageSeenStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessageSeenStatus(requestParameters.messageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import a new message in an inbox.
         * @summary Import message
         * @param {MessagesApiImportNewInboxMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importNewInboxMessage(requestParameters: MessagesApiImportNewInboxMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessagesReceiveCustomMessageResponse>> {
            const importMessage: ImportMessage = {
                tags: requestParameters.tags,
                sender: requestParameters.sender,
                to: requestParameters.to,
                cc: requestParameters.cc,
                bcc: requestParameters.bcc,
                subject: requestParameters.subject,
                body: requestParameters.body,
                body_format: requestParameters.body_format,
                external_id: requestParameters.external_id,
                created_at: requestParameters.created_at,
                type: requestParameters.type,
                assignee_id: requestParameters.assignee_id,
                conversation_id: requestParameters.conversation_id,
                metadata: requestParameters.metadata,
                attachments: requestParameters.attachments
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.importNewInboxMessage(requestParameters.inboxId, importMessage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark an outbound message from Front as seen. Note, the message seen route should only be called in response to an actual end-user\'s message-seen action. In accordance with this behavior, the route is rate limited to 10 requests per hour. The request body should send an empty object.
         * @summary Mark message seen
         * @param {MessagesApiMarkMessageSeenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markMessageSeen(requestParameters: MessagesApiMarkMessageSeenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const body: object = {
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.markMessageSeen(requestParameters.messageId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Receive a custom message in Front. This endpoint is available for custom channels **ONLY**.
         * @summary Receive custom messages
         * @param {MessagesApiReceiveCustomMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async receiveCustomMessage(requestParameters: MessagesApiReceiveCustomMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessagesReceiveCustomMessageResponse>> {
            const customMessage: CustomMessage = {
                sender: requestParameters.sender,
                subject: requestParameters.subject,
                body: requestParameters.body,
                body_format: requestParameters.body_format,
                metadata: requestParameters.metadata,
                attachments: requestParameters.attachments
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.receiveCustomMessage(requestParameters.channelId, customMessage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * Reply to a conversation by sending a message and appending it to the conversation.
         * @summary Create message reply
         * @param {MessagesApiCreateMessageReplyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessageReply(requestParameters: MessagesApiCreateMessageReplyRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createMessageReply(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a new message from a channel. This is one of the ways to create a new [conversation](https://dev.frontapp.com/reference/conversations#creating-a-new-conversation). The new conversation will support both messages and comments (discussions).
         * @summary Create message
         * @param {MessagesApiCreateNewMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewMessage(requestParameters: MessagesApiCreateNewMessageRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createNewMessage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a message.  > ℹ️ The HTTP Header `Accept` can be used to request the message in a different format. > By default, Front will return the documented JSON response. By requesting `message/rfc822`, the response will contain the message in the EML format (for email messages only). 
         * @summary Get message
         * @param {MessagesApiGetMessageByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById(requestParameters: MessagesApiGetMessageByIdRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getMessageById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the seen receipts for the given message. If no seen-by information is available, there will be a single entry for the first time the message was seen by any recipient. If seen-by information is available, there will be an entry for each recipient who has seen the message.
         * @summary Get message seen status
         * @param {MessagesApiGetMessageSeenStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageSeenStatus(requestParameters: MessagesApiGetMessageSeenStatusRequest, options?: AxiosRequestConfig): AxiosPromise<MessagesGetMessageSeenStatusResponse> {
            return localVarFp.getMessageSeenStatus(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Import a new message in an inbox.
         * @summary Import message
         * @param {MessagesApiImportNewInboxMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importNewInboxMessage(requestParameters: MessagesApiImportNewInboxMessageRequest, options?: AxiosRequestConfig): AxiosPromise<MessagesReceiveCustomMessageResponse> {
            return localVarFp.importNewInboxMessage(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark an outbound message from Front as seen. Note, the message seen route should only be called in response to an actual end-user\'s message-seen action. In accordance with this behavior, the route is rate limited to 10 requests per hour. The request body should send an empty object.
         * @summary Mark message seen
         * @param {MessagesApiMarkMessageSeenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markMessageSeen(requestParameters: MessagesApiMarkMessageSeenRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.markMessageSeen(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Receive a custom message in Front. This endpoint is available for custom channels **ONLY**.
         * @summary Receive custom messages
         * @param {MessagesApiReceiveCustomMessageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        receiveCustomMessage(requestParameters: MessagesApiReceiveCustomMessageRequest, options?: AxiosRequestConfig): AxiosPromise<MessagesReceiveCustomMessageResponse> {
            return localVarFp.receiveCustomMessage(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createMessageReply operation in MessagesApi.
 * @export
 * @interface MessagesApiCreateMessageReplyRequest
 */
export type MessagesApiCreateMessageReplyRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof MessagesApiCreateMessageReply
    */
    readonly conversationId: string
    
} & OutboundReplyMessage

/**
 * Request parameters for createNewMessage operation in MessagesApi.
 * @export
 * @interface MessagesApiCreateNewMessageRequest
 */
export type MessagesApiCreateNewMessageRequest = {
    
    /**
    * The sending channel ID. Alternatively, you can supply the sending channel address as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
    * @type {string}
    * @memberof MessagesApiCreateNewMessage
    */
    readonly channelId: string
    
} & OutboundMessage

/**
 * Request parameters for getMessageById operation in MessagesApi.
 * @export
 * @interface MessagesApiGetMessageByIdRequest
 */
export type MessagesApiGetMessageByIdRequest = {
    
    /**
    * The message ID
    * @type {string}
    * @memberof MessagesApiGetMessageById
    */
    readonly messageId: string
    
}

/**
 * Request parameters for getMessageSeenStatus operation in MessagesApi.
 * @export
 * @interface MessagesApiGetMessageSeenStatusRequest
 */
export type MessagesApiGetMessageSeenStatusRequest = {
    
    /**
    * The message ID
    * @type {string}
    * @memberof MessagesApiGetMessageSeenStatus
    */
    readonly messageId: string
    
}

/**
 * Request parameters for importNewInboxMessage operation in MessagesApi.
 * @export
 * @interface MessagesApiImportNewInboxMessageRequest
 */
export type MessagesApiImportNewInboxMessageRequest = {
    
    /**
    * The Inbox ID
    * @type {string}
    * @memberof MessagesApiImportNewInboxMessage
    */
    readonly inboxId: string
    
} & ImportMessage

/**
 * Request parameters for markMessageSeen operation in MessagesApi.
 * @export
 * @interface MessagesApiMarkMessageSeenRequest
 */
export type MessagesApiMarkMessageSeenRequest = {
    
    /**
    * The message ID
    * @type {string}
    * @memberof MessagesApiMarkMessageSeen
    */
    readonly messageId: string
    
} & object

/**
 * Request parameters for receiveCustomMessage operation in MessagesApi.
 * @export
 * @interface MessagesApiReceiveCustomMessageRequest
 */
export type MessagesApiReceiveCustomMessageRequest = {
    
    /**
    * The channel ID. Alternatively, you can supply the channel address as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
    * @type {string}
    * @memberof MessagesApiReceiveCustomMessage
    */
    readonly channelId: string
    
} & CustomMessage

/**
 * MessagesApiGenerated - object-oriented interface
 * @export
 * @class MessagesApiGenerated
 * @extends {BaseAPI}
 */
export class MessagesApiGenerated extends BaseAPI {
    /**
     * Reply to a conversation by sending a message and appending it to the conversation.
     * @summary Create message reply
     * @param {MessagesApiCreateMessageReplyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiGenerated
     */
    public createMessageReply(requestParameters: MessagesApiCreateMessageReplyRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).createMessageReply(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a new message from a channel. This is one of the ways to create a new [conversation](https://dev.frontapp.com/reference/conversations#creating-a-new-conversation). The new conversation will support both messages and comments (discussions).
     * @summary Create message
     * @param {MessagesApiCreateNewMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiGenerated
     */
    public createNewMessage(requestParameters: MessagesApiCreateNewMessageRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).createNewMessage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a message.  > ℹ️ The HTTP Header `Accept` can be used to request the message in a different format. > By default, Front will return the documented JSON response. By requesting `message/rfc822`, the response will contain the message in the EML format (for email messages only). 
     * @summary Get message
     * @param {MessagesApiGetMessageByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiGenerated
     */
    public getMessageById(requestParameters: MessagesApiGetMessageByIdRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).getMessageById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the seen receipts for the given message. If no seen-by information is available, there will be a single entry for the first time the message was seen by any recipient. If seen-by information is available, there will be an entry for each recipient who has seen the message.
     * @summary Get message seen status
     * @param {MessagesApiGetMessageSeenStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiGenerated
     */
    public getMessageSeenStatus(requestParameters: MessagesApiGetMessageSeenStatusRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).getMessageSeenStatus(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import a new message in an inbox.
     * @summary Import message
     * @param {MessagesApiImportNewInboxMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiGenerated
     */
    public importNewInboxMessage(requestParameters: MessagesApiImportNewInboxMessageRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).importNewInboxMessage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark an outbound message from Front as seen. Note, the message seen route should only be called in response to an actual end-user\'s message-seen action. In accordance with this behavior, the route is rate limited to 10 requests per hour. The request body should send an empty object.
     * @summary Mark message seen
     * @param {MessagesApiMarkMessageSeenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiGenerated
     */
    public markMessageSeen(requestParameters: MessagesApiMarkMessageSeenRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).markMessageSeen(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receive a custom message in Front. This endpoint is available for custom channels **ONLY**.
     * @summary Receive custom messages
     * @param {MessagesApiReceiveCustomMessageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApiGenerated
     */
    public receiveCustomMessage(requestParameters: MessagesApiReceiveCustomMessageRequest, options?: AxiosRequestConfig) {
        return MessagesApiFp(this.configuration).receiveCustomMessage(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
