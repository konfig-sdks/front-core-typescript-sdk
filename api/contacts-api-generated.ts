/* tslint:disable */
/* eslint-disable */
/*
Core API

Front is a customer operations platform that enables support, sales, and account management teams to deliver exceptional service at scale. Front streamlines customer communication by combining the efficiency of a help desk and the familiarity of email, with automated workflows and real-time collaboration behind the scenes.

With Front, teams can centralize messages across channels, route them to the right person, and unlock visibility and insights across all of their customer operations. More than 8000 businesses use Front to drive operational efficiency that prevents churn, improves retention, and propels customer growth.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AccountsListAccountContactsResponse } from '../models';
// @ts-ignore
import { Contact } from '../models';
// @ts-ignore
import { ContactHandle } from '../models';
// @ts-ignore
import { ContactsListConversationsReverseChronologicalOrderResponse } from '../models';
// @ts-ignore
import { CreateContact } from '../models';
// @ts-ignore
import { MergeContacts } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * ContactsApi - axios parameter creator
 * @export
 */
export const ContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new contact.
         * @summary Create contact
         * @param {CreateContact} [createContact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewContact: async (createContact?: CreateContact, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: createContact,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/contacts',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(createContact, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a contact for a team (workspace).
         * @summary Create team contact
         * @param {string} teamId The team ID
         * @param {CreateContact} [createContact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamContact: async (teamId: string, createContact?: CreateContact, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('createTeamContact', 'teamId', teamId)
            const localVarPath = `/teams/{team_id}/contacts`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId !== undefined ? teamId : `-team_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: createContact,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/teams/{team_id}/contacts',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(createContact, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a contact for a teammate.
         * @summary Create teammate contact
         * @param {string} teammateId The teammate ID. Alternatively, you can supply an email as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
         * @param {CreateContact} [createContact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeammateContact: async (teammateId: string, createContact?: CreateContact, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teammateId' is not null or undefined
            assertParamExists('createTeammateContact', 'teammateId', teammateId)
            const localVarPath = `/teammates/{teammate_id}/contacts`
                .replace(`{${"teammate_id"}}`, encodeURIComponent(String(teammateId !== undefined ? teammateId : `-teammate_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: createContact,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/teammates/{teammate_id}/contacts',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(createContact, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a contact.
         * @summary Delete a contact
         * @param {string} contactId The contact ID. Alternatively, you can supply the contact\&#39;s source and handle as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact: async (contactId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('deleteContact', 'contactId', contactId)
            const localVarPath = `/contacts/{contact_id}`
                .replace(`{${"contact_id"}}`, encodeURIComponent(String(contactId !== undefined ? contactId : `-contact_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/contacts/{contact_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a contact.
         * @summary Get contact
         * @param {string} contactId The contact ID. Alternatively, you can supply the contact\&#39;s source and handle as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneContact: async (contactId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('getOneContact', 'contactId', contactId)
            const localVarPath = `/contacts/{contact_id}`
                .replace(`{${"contact_id"}}`, encodeURIComponent(String(contactId !== undefined ? contactId : `-contact_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/contacts/{contact_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the contacts of the company.
         * @summary List contacts
         * @param {string} [q] [Search query object](https://dev.frontapp.com/docs/query-object-q) with the optional properties &#x60;updated_after&#x60; and &#x60;updated_before&#x60;, whose value should be a timestamp in seconds with up to 3 decimal places.
         * @param {number} [limit] Max number of results per [page](https://dev.frontapp.com/docs/pagination)
         * @param {string} [pageToken] Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
         * @param {string} [sortBy] Field used to sort the contacts. Either &#x60;created_at&#x60; or &#x60;updated_at&#x60;.
         * @param {'asc' | 'desc'} [sortOrder] Order by which results should be sorted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCompanyContacts: async (q?: string, limit?: number, pageToken?: string, sortBy?: string, sortOrder?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/contacts',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the conversations for a contact in reverse chronological order (newest first). For more advanced filtering, see the [search endpoint](https://dev.frontapp.com/reference/conversations#search-conversations). 
         * @summary List contact conversations
         * @param {string} contactId The Contact ID. Alternatively, you can supply the contact\&#39;s source and handle as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
         * @param {string} [q] [Search query object](https://dev.frontapp.com/docs/query-object-q) with a property &#x60;statuses&#x60;, whose value should be a list of conversation statuses (&#x60;assigned&#x60;, &#x60;unassigned&#x60;, &#x60;archived&#x60;, or &#x60;deleted&#x60;).
         * @param {number} [limit] Max number of results per [page](https://dev.frontapp.com/docs/pagination)
         * @param {string} [pageToken] Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsReverseChronologicalOrder: async (contactId: string, q?: string, limit?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('listConversationsReverseChronologicalOrder', 'contactId', contactId)
            const localVarPath = `/contacts/{contact_id}/conversations`
                .replace(`{${"contact_id"}}`, encodeURIComponent(String(contactId !== undefined ? contactId : `-contact_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/contacts/{contact_id}/conversations',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the contacts of a team (workspace).
         * @summary List team contacts
         * @param {string} teamId The team ID
         * @param {string} [q] [Search query object](https://dev.frontapp.com/docs/query-object-q) with the optional properties &#x60;updated_after&#x60; and &#x60;updated_before&#x60;, whose value should be a timestamp in seconds with up to 3 decimal places.
         * @param {number} [limit] Max number of results per [page](https://dev.frontapp.com/docs/pagination)
         * @param {string} [pageToken] Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
         * @param {string} [sortBy] Field used to sort the contacts. Either &#x60;created_at&#x60; or &#x60;updated_at&#x60;.
         * @param {'asc' | 'desc'} [sortOrder] Order by which results should be sorted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamContacts: async (teamId: string, q?: string, limit?: number, pageToken?: string, sortBy?: string, sortOrder?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('listTeamContacts', 'teamId', teamId)
            const localVarPath = `/teams/{team_id}/contacts`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId !== undefined ? teamId : `-team_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/teams/{team_id}/contacts',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the contacts of a teammate.
         * @summary List teammate contacts
         * @param {string} teammateId The teammate ID. Alternatively, you can supply an email as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
         * @param {string} [q] [Search query object](https://dev.frontapp.com/docs/query-object-q) with the optional properties &#x60;updated_after&#x60; and &#x60;updated_before&#x60;, whose value should be a timestamp in seconds with up to 3 decimal places.
         * @param {number} [limit] Max number of results per [page](https://dev.frontapp.com/docs/pagination)
         * @param {string} [pageToken] Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
         * @param {string} [sortBy] Field used to sort the contacts. Either &#x60;created_at&#x60; or &#x60;updated_at&#x60;.
         * @param {'asc' | 'desc'} [sortOrder] Order by which results should be sorted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeammateContacts: async (teammateId: string, q?: string, limit?: number, pageToken?: string, sortBy?: string, sortOrder?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teammateId' is not null or undefined
            assertParamExists('listTeammateContacts', 'teammateId', teammateId)
            const localVarPath = `/teammates/{teammate_id}/contacts`
                .replace(`{${"teammate_id"}}`, encodeURIComponent(String(teammateId !== undefined ? teammateId : `-teammate_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/teammates/{teammate_id}/contacts',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Merges the contacts specified into a single contact, deleting the merged-in contacts. If a target contact ID is supplied, the other contacts will be merged into that one. Otherwise, some contact in the contact ID list will be treated as the target contact. Merge conflicts will be resolved in the following ways:   * name will prioritize manually-updated and non-private contact names   * descriptions will be concatenated and separated by newlines in order from     oldest to newest with the (optional) target contact\'s description first   * all handles, groups, links, and notes will be preserved   * other conflicts will use the most recently updated contact\'s value 
         * @summary Merge contacts
         * @param {MergeContacts} [mergeContacts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeContacts: async (mergeContacts?: MergeContacts, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contacts/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: mergeContacts,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/contacts/merge',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(mergeContacts, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a contact.
         * @summary Update a contact
         * @param {string} contactId The contact ID. Alternatively, you can supply the contact\&#39;s source and handle as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
         * @param {Contact} [contact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact: async (contactId: string, contact?: Contact, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactId' is not null or undefined
            assertParamExists('updateContact', 'contactId', contactId)
            const localVarPath = `/contacts/{contact_id}`
                .replace(`{${"contact_id"}}`, encodeURIComponent(String(contactId !== undefined ? contactId : `-contact_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: contact,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/contacts/{contact_id}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(contact, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactsApi - functional programming interface
 * @export
 */
export const ContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new contact.
         * @summary Create contact
         * @param {ContactsApiCreateNewContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewContact(requestParameters: ContactsApiCreateNewContactRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const createContact: CreateContact = {
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewContact(createContact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a contact for a team (workspace).
         * @summary Create team contact
         * @param {ContactsApiCreateTeamContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeamContact(requestParameters: ContactsApiCreateTeamContactRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const createContact: CreateContact = {
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeamContact(requestParameters.teamId, createContact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a contact for a teammate.
         * @summary Create teammate contact
         * @param {ContactsApiCreateTeammateContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeammateContact(requestParameters: ContactsApiCreateTeammateContactRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const createContact: CreateContact = {
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeammateContact(requestParameters.teammateId, createContact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a contact.
         * @summary Delete a contact
         * @param {ContactsApiDeleteContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContact(requestParameters: ContactsApiDeleteContactRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContact(requestParameters.contactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a contact.
         * @summary Get contact
         * @param {ContactsApiGetOneContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneContact(requestParameters: ContactsApiGetOneContactRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneContact(requestParameters.contactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the contacts of the company.
         * @summary List contacts
         * @param {ContactsApiListCompanyContactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCompanyContacts(requestParameters: ContactsApiListCompanyContactsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsListAccountContactsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCompanyContacts(requestParameters.q, requestParameters.limit, requestParameters.pageToken, requestParameters.sortBy, requestParameters.sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the conversations for a contact in reverse chronological order (newest first). For more advanced filtering, see the [search endpoint](https://dev.frontapp.com/reference/conversations#search-conversations). 
         * @summary List contact conversations
         * @param {ContactsApiListConversationsReverseChronologicalOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversationsReverseChronologicalOrder(requestParameters: ContactsApiListConversationsReverseChronologicalOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsListConversationsReverseChronologicalOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConversationsReverseChronologicalOrder(requestParameters.contactId, requestParameters.q, requestParameters.limit, requestParameters.pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the contacts of a team (workspace).
         * @summary List team contacts
         * @param {ContactsApiListTeamContactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTeamContacts(requestParameters: ContactsApiListTeamContactsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsListAccountContactsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTeamContacts(requestParameters.teamId, requestParameters.q, requestParameters.limit, requestParameters.pageToken, requestParameters.sortBy, requestParameters.sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the contacts of a teammate.
         * @summary List teammate contacts
         * @param {ContactsApiListTeammateContactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTeammateContacts(requestParameters: ContactsApiListTeammateContactsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsListAccountContactsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTeammateContacts(requestParameters.teammateId, requestParameters.q, requestParameters.limit, requestParameters.pageToken, requestParameters.sortBy, requestParameters.sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Merges the contacts specified into a single contact, deleting the merged-in contacts. If a target contact ID is supplied, the other contacts will be merged into that one. Otherwise, some contact in the contact ID list will be treated as the target contact. Merge conflicts will be resolved in the following ways:   * name will prioritize manually-updated and non-private contact names   * descriptions will be concatenated and separated by newlines in order from     oldest to newest with the (optional) target contact\'s description first   * all handles, groups, links, and notes will be preserved   * other conflicts will use the most recently updated contact\'s value 
         * @summary Merge contacts
         * @param {ContactsApiMergeContactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeContacts(requestParameters: ContactsApiMergeContactsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const mergeContacts: MergeContacts = {
                target_contact_id: requestParameters.target_contact_id,
                contact_ids: requestParameters.contact_ids
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeContacts(mergeContacts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a contact.
         * @summary Update a contact
         * @param {ContactsApiUpdateContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContact(requestParameters: ContactsApiUpdateContactRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const contact: Contact = {
                description: requestParameters.description,
                name: requestParameters.name,
                avatar: requestParameters.avatar,
                is_spammer: requestParameters.is_spammer,
                links: requestParameters.links,
                group_names: requestParameters.group_names,
                custom_fields: requestParameters.custom_fields
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContact(requestParameters.contactId, contact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContactsApi - factory interface
 * @export
 */
export const ContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContactsApiFp(configuration)
    return {
        /**
         * Create a new contact.
         * @summary Create contact
         * @param {ContactsApiCreateNewContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewContact(requestParameters: ContactsApiCreateNewContactRequest = {}, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createNewContact(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a contact for a team (workspace).
         * @summary Create team contact
         * @param {ContactsApiCreateTeamContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeamContact(requestParameters: ContactsApiCreateTeamContactRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createTeamContact(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a contact for a teammate.
         * @summary Create teammate contact
         * @param {ContactsApiCreateTeammateContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeammateContact(requestParameters: ContactsApiCreateTeammateContactRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createTeammateContact(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a contact.
         * @summary Delete a contact
         * @param {ContactsApiDeleteContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact(requestParameters: ContactsApiDeleteContactRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteContact(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a contact.
         * @summary Get contact
         * @param {ContactsApiGetOneContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneContact(requestParameters: ContactsApiGetOneContactRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getOneContact(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List the contacts of the company.
         * @summary List contacts
         * @param {ContactsApiListCompanyContactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCompanyContacts(requestParameters: ContactsApiListCompanyContactsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<AccountsListAccountContactsResponse> {
            return localVarFp.listCompanyContacts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List the conversations for a contact in reverse chronological order (newest first). For more advanced filtering, see the [search endpoint](https://dev.frontapp.com/reference/conversations#search-conversations). 
         * @summary List contact conversations
         * @param {ContactsApiListConversationsReverseChronologicalOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsReverseChronologicalOrder(requestParameters: ContactsApiListConversationsReverseChronologicalOrderRequest, options?: AxiosRequestConfig): AxiosPromise<ContactsListConversationsReverseChronologicalOrderResponse> {
            return localVarFp.listConversationsReverseChronologicalOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List the contacts of a team (workspace).
         * @summary List team contacts
         * @param {ContactsApiListTeamContactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamContacts(requestParameters: ContactsApiListTeamContactsRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsListAccountContactsResponse> {
            return localVarFp.listTeamContacts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List the contacts of a teammate.
         * @summary List teammate contacts
         * @param {ContactsApiListTeammateContactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeammateContacts(requestParameters: ContactsApiListTeammateContactsRequest, options?: AxiosRequestConfig): AxiosPromise<AccountsListAccountContactsResponse> {
            return localVarFp.listTeammateContacts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Merges the contacts specified into a single contact, deleting the merged-in contacts. If a target contact ID is supplied, the other contacts will be merged into that one. Otherwise, some contact in the contact ID list will be treated as the target contact. Merge conflicts will be resolved in the following ways:   * name will prioritize manually-updated and non-private contact names   * descriptions will be concatenated and separated by newlines in order from     oldest to newest with the (optional) target contact\'s description first   * all handles, groups, links, and notes will be preserved   * other conflicts will use the most recently updated contact\'s value 
         * @summary Merge contacts
         * @param {ContactsApiMergeContactsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeContacts(requestParameters: ContactsApiMergeContactsRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.mergeContacts(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a contact.
         * @summary Update a contact
         * @param {ContactsApiUpdateContactRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact(requestParameters: ContactsApiUpdateContactRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateContact(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNewContact operation in ContactsApi.
 * @export
 * @interface ContactsApiCreateNewContactRequest
 */
export type ContactsApiCreateNewContactRequest = {
    
} & CreateContact

/**
 * Request parameters for createTeamContact operation in ContactsApi.
 * @export
 * @interface ContactsApiCreateTeamContactRequest
 */
export type ContactsApiCreateTeamContactRequest = {
    
    /**
    * The team ID
    * @type {string}
    * @memberof ContactsApiCreateTeamContact
    */
    readonly teamId: string
    
} & CreateContact

/**
 * Request parameters for createTeammateContact operation in ContactsApi.
 * @export
 * @interface ContactsApiCreateTeammateContactRequest
 */
export type ContactsApiCreateTeammateContactRequest = {
    
    /**
    * The teammate ID. Alternatively, you can supply an email as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
    * @type {string}
    * @memberof ContactsApiCreateTeammateContact
    */
    readonly teammateId: string
    
} & CreateContact

/**
 * Request parameters for deleteContact operation in ContactsApi.
 * @export
 * @interface ContactsApiDeleteContactRequest
 */
export type ContactsApiDeleteContactRequest = {
    
    /**
    * The contact ID. Alternatively, you can supply the contact\'s source and handle as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
    * @type {string}
    * @memberof ContactsApiDeleteContact
    */
    readonly contactId: string
    
}

/**
 * Request parameters for getOneContact operation in ContactsApi.
 * @export
 * @interface ContactsApiGetOneContactRequest
 */
export type ContactsApiGetOneContactRequest = {
    
    /**
    * The contact ID. Alternatively, you can supply the contact\'s source and handle as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
    * @type {string}
    * @memberof ContactsApiGetOneContact
    */
    readonly contactId: string
    
}

/**
 * Request parameters for listCompanyContacts operation in ContactsApi.
 * @export
 * @interface ContactsApiListCompanyContactsRequest
 */
export type ContactsApiListCompanyContactsRequest = {
    
    /**
    * [Search query object](https://dev.frontapp.com/docs/query-object-q) with the optional properties `updated_after` and `updated_before`, whose value should be a timestamp in seconds with up to 3 decimal places.
    * @type {string}
    * @memberof ContactsApiListCompanyContacts
    */
    readonly q?: string
    
    /**
    * Max number of results per [page](https://dev.frontapp.com/docs/pagination)
    * @type {number}
    * @memberof ContactsApiListCompanyContacts
    */
    readonly limit?: number
    
    /**
    * Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
    * @type {string}
    * @memberof ContactsApiListCompanyContacts
    */
    readonly pageToken?: string
    
    /**
    * Field used to sort the contacts. Either `created_at` or `updated_at`.
    * @type {string}
    * @memberof ContactsApiListCompanyContacts
    */
    readonly sortBy?: string
    
    /**
    * Order by which results should be sorted
    * @type {'asc' | 'desc'}
    * @memberof ContactsApiListCompanyContacts
    */
    readonly sortOrder?: 'asc' | 'desc'
    
}

/**
 * Request parameters for listConversationsReverseChronologicalOrder operation in ContactsApi.
 * @export
 * @interface ContactsApiListConversationsReverseChronologicalOrderRequest
 */
export type ContactsApiListConversationsReverseChronologicalOrderRequest = {
    
    /**
    * The Contact ID. Alternatively, you can supply the contact\'s source and handle as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
    * @type {string}
    * @memberof ContactsApiListConversationsReverseChronologicalOrder
    */
    readonly contactId: string
    
    /**
    * [Search query object](https://dev.frontapp.com/docs/query-object-q) with a property `statuses`, whose value should be a list of conversation statuses (`assigned`, `unassigned`, `archived`, or `deleted`).
    * @type {string}
    * @memberof ContactsApiListConversationsReverseChronologicalOrder
    */
    readonly q?: string
    
    /**
    * Max number of results per [page](https://dev.frontapp.com/docs/pagination)
    * @type {number}
    * @memberof ContactsApiListConversationsReverseChronologicalOrder
    */
    readonly limit?: number
    
    /**
    * Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
    * @type {string}
    * @memberof ContactsApiListConversationsReverseChronologicalOrder
    */
    readonly pageToken?: string
    
}

/**
 * Request parameters for listTeamContacts operation in ContactsApi.
 * @export
 * @interface ContactsApiListTeamContactsRequest
 */
export type ContactsApiListTeamContactsRequest = {
    
    /**
    * The team ID
    * @type {string}
    * @memberof ContactsApiListTeamContacts
    */
    readonly teamId: string
    
    /**
    * [Search query object](https://dev.frontapp.com/docs/query-object-q) with the optional properties `updated_after` and `updated_before`, whose value should be a timestamp in seconds with up to 3 decimal places.
    * @type {string}
    * @memberof ContactsApiListTeamContacts
    */
    readonly q?: string
    
    /**
    * Max number of results per [page](https://dev.frontapp.com/docs/pagination)
    * @type {number}
    * @memberof ContactsApiListTeamContacts
    */
    readonly limit?: number
    
    /**
    * Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
    * @type {string}
    * @memberof ContactsApiListTeamContacts
    */
    readonly pageToken?: string
    
    /**
    * Field used to sort the contacts. Either `created_at` or `updated_at`.
    * @type {string}
    * @memberof ContactsApiListTeamContacts
    */
    readonly sortBy?: string
    
    /**
    * Order by which results should be sorted
    * @type {'asc' | 'desc'}
    * @memberof ContactsApiListTeamContacts
    */
    readonly sortOrder?: 'asc' | 'desc'
    
}

/**
 * Request parameters for listTeammateContacts operation in ContactsApi.
 * @export
 * @interface ContactsApiListTeammateContactsRequest
 */
export type ContactsApiListTeammateContactsRequest = {
    
    /**
    * The teammate ID. Alternatively, you can supply an email as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
    * @type {string}
    * @memberof ContactsApiListTeammateContacts
    */
    readonly teammateId: string
    
    /**
    * [Search query object](https://dev.frontapp.com/docs/query-object-q) with the optional properties `updated_after` and `updated_before`, whose value should be a timestamp in seconds with up to 3 decimal places.
    * @type {string}
    * @memberof ContactsApiListTeammateContacts
    */
    readonly q?: string
    
    /**
    * Max number of results per [page](https://dev.frontapp.com/docs/pagination)
    * @type {number}
    * @memberof ContactsApiListTeammateContacts
    */
    readonly limit?: number
    
    /**
    * Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
    * @type {string}
    * @memberof ContactsApiListTeammateContacts
    */
    readonly pageToken?: string
    
    /**
    * Field used to sort the contacts. Either `created_at` or `updated_at`.
    * @type {string}
    * @memberof ContactsApiListTeammateContacts
    */
    readonly sortBy?: string
    
    /**
    * Order by which results should be sorted
    * @type {'asc' | 'desc'}
    * @memberof ContactsApiListTeammateContacts
    */
    readonly sortOrder?: 'asc' | 'desc'
    
}

/**
 * Request parameters for mergeContacts operation in ContactsApi.
 * @export
 * @interface ContactsApiMergeContactsRequest
 */
export type ContactsApiMergeContactsRequest = {
    
} & MergeContacts

/**
 * Request parameters for updateContact operation in ContactsApi.
 * @export
 * @interface ContactsApiUpdateContactRequest
 */
export type ContactsApiUpdateContactRequest = {
    
    /**
    * The contact ID. Alternatively, you can supply the contact\'s source and handle as a [resource alias](https://dev.frontapp.com/docs/resource-aliases-1).
    * @type {string}
    * @memberof ContactsApiUpdateContact
    */
    readonly contactId: string
    
} & Contact

/**
 * ContactsApiGenerated - object-oriented interface
 * @export
 * @class ContactsApiGenerated
 * @extends {BaseAPI}
 */
export class ContactsApiGenerated extends BaseAPI {
    /**
     * Create a new contact.
     * @summary Create contact
     * @param {ContactsApiCreateNewContactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApiGenerated
     */
    public createNewContact(requestParameters: ContactsApiCreateNewContactRequest = {}, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).createNewContact(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a contact for a team (workspace).
     * @summary Create team contact
     * @param {ContactsApiCreateTeamContactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApiGenerated
     */
    public createTeamContact(requestParameters: ContactsApiCreateTeamContactRequest, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).createTeamContact(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a contact for a teammate.
     * @summary Create teammate contact
     * @param {ContactsApiCreateTeammateContactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApiGenerated
     */
    public createTeammateContact(requestParameters: ContactsApiCreateTeammateContactRequest, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).createTeammateContact(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a contact.
     * @summary Delete a contact
     * @param {ContactsApiDeleteContactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApiGenerated
     */
    public deleteContact(requestParameters: ContactsApiDeleteContactRequest, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).deleteContact(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a contact.
     * @summary Get contact
     * @param {ContactsApiGetOneContactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApiGenerated
     */
    public getOneContact(requestParameters: ContactsApiGetOneContactRequest, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).getOneContact(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the contacts of the company.
     * @summary List contacts
     * @param {ContactsApiListCompanyContactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApiGenerated
     */
    public listCompanyContacts(requestParameters: ContactsApiListCompanyContactsRequest = {}, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).listCompanyContacts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the conversations for a contact in reverse chronological order (newest first). For more advanced filtering, see the [search endpoint](https://dev.frontapp.com/reference/conversations#search-conversations). 
     * @summary List contact conversations
     * @param {ContactsApiListConversationsReverseChronologicalOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApiGenerated
     */
    public listConversationsReverseChronologicalOrder(requestParameters: ContactsApiListConversationsReverseChronologicalOrderRequest, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).listConversationsReverseChronologicalOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the contacts of a team (workspace).
     * @summary List team contacts
     * @param {ContactsApiListTeamContactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApiGenerated
     */
    public listTeamContacts(requestParameters: ContactsApiListTeamContactsRequest, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).listTeamContacts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the contacts of a teammate.
     * @summary List teammate contacts
     * @param {ContactsApiListTeammateContactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApiGenerated
     */
    public listTeammateContacts(requestParameters: ContactsApiListTeammateContactsRequest, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).listTeammateContacts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Merges the contacts specified into a single contact, deleting the merged-in contacts. If a target contact ID is supplied, the other contacts will be merged into that one. Otherwise, some contact in the contact ID list will be treated as the target contact. Merge conflicts will be resolved in the following ways:   * name will prioritize manually-updated and non-private contact names   * descriptions will be concatenated and separated by newlines in order from     oldest to newest with the (optional) target contact\'s description first   * all handles, groups, links, and notes will be preserved   * other conflicts will use the most recently updated contact\'s value 
     * @summary Merge contacts
     * @param {ContactsApiMergeContactsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApiGenerated
     */
    public mergeContacts(requestParameters: ContactsApiMergeContactsRequest, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).mergeContacts(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a contact.
     * @summary Update a contact
     * @param {ContactsApiUpdateContactRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactsApiGenerated
     */
    public updateContact(requestParameters: ContactsApiUpdateContactRequest, options?: AxiosRequestConfig) {
        return ContactsApiFp(this.configuration).updateContact(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
