/* tslint:disable */
/* eslint-disable */
/*
Core API

Front is a customer operations platform that enables support, sales, and account management teams to deliver exceptional service at scale. Front streamlines customer communication by combining the efficiency of a help desk and the familiarity of email, with automated workflows and real-time collaboration behind the scenes.

With Front, teams can centralize messages across channels, route them to the right person, and unlock visibility and insights across all of their customer operations. More than 8000 businesses use Front to drive operational efficiency that prevents churn, improves retention, and propels customer growth.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { CommentsListMentionedTeammatesResponse } from '../models';
// @ts-ignore
import { ContactsListConversationsReverseChronologicalOrderResponse } from '../models';
// @ts-ignore
import { ConversationsAddFollowersRequest } from '../models';
// @ts-ignore
import { ConversationsAddLinkRequest } from '../models';
// @ts-ignore
import { ConversationsListEventsResponse } from '../models';
// @ts-ignore
import { ConversationsListInboxesResponse } from '../models';
// @ts-ignore
import { ConversationsRemoveFollowersRequest } from '../models';
// @ts-ignore
import { ConversationsRemoveLinksRequest } from '../models';
// @ts-ignore
import { ConversationsSearchByQueryResponse } from '../models';
// @ts-ignore
import { CreateConversation } from '../models';
// @ts-ignore
import { CreateConversationComment } from '../models';
// @ts-ignore
import { DraftsListConversationDraftsResponse } from '../models';
// @ts-ignore
import { TagIds } from '../models';
// @ts-ignore
import { UpdateConversation } from '../models';
// @ts-ignore
import { UpdateConversationAssignee } from '../models';
// @ts-ignore
import { UpdateConversationReminders } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * ConversationsApi - axios parameter creator
 * @export
 */
export const ConversationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds teammates to the list of followers of a conversation.
         * @summary Add conversation followers
         * @param {string} conversationId The conversation ID
         * @param {ConversationsAddFollowersRequest} [conversationsAddFollowersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFollowers: async (conversationId: string, conversationsAddFollowersRequest?: ConversationsAddFollowersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('addFollowers', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}/followers`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsAddFollowersRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}/followers',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsAddFollowersRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds one or more links to a conversation
         * @summary Add conversation link
         * @param {string} conversationId The conversation ID
         * @param {ConversationsAddLinkRequest} [conversationsAddLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLink: async (conversationId: string, conversationsAddLinkRequest?: ConversationsAddLinkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('addLink', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsAddLinkRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}/links',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsAddLinkRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds one or more tags to a conversation
         * @summary Add conversation tag
         * @param {string} conversationId The conversation ID
         * @param {TagIds} [tagIds] Tag IDs to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagsToConversation: async (conversationId: string, tagIds?: TagIds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('addTagsToConversation', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}/tags`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: tagIds,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}/tags',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(tagIds, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new [conversation](https://dev.frontapp.com/reference/conversations#creating-a-new-conversation) that only supports comments (known as discussions in Front). If you want to create a conversation that supports messages, use the [Create message](https://dev.frontapp.com/reference/post_channels-channel-id-messages) endpoint. If you want to add a comment to an existing conversation, use the [Add comment](https://dev.frontapp.com/reference/post_conversations-conversation-id-comments) endpoint.
         * @summary Create discussion conversation
         * @param {CreateConversation} [createConversation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscussion: async (createConversation?: CreateConversation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: createConversation,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(createConversation, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a conversation. 
         * @summary Get conversation
         * @param {string} conversationId The conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (conversationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('getById', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the events that occured for a conversation in reverse chronological order (newest first). The order will respect your company\'s [bump settings](https://help.front.com/t/y729th/customize-when-conversations-bump-up), which determine when conversations bump to the top.
         * @summary List conversation events
         * @param {string} conversationId The conversation ID
         * @param {number} [limit] Max number of results per [page](https://dev.frontapp.com/docs/pagination)
         * @param {string} [pageToken] Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents: async (conversationId: string, limit?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('listEvents', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}/events`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}/events',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the teammates following a conversation.
         * @summary List conversation followers
         * @param {string} conversationId The conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFollowers: async (conversationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('listFollowers', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}/followers`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}/followers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the conversations in the company in reverse chronological order (most recently updated first). The order will respect your company\'s [bump settings](https://help.front.com/t/y729th/customize-when-conversations-bump-up), which determine when conversations bump to the top. For more advanced filtering, see the [search endpoint](https://dev.frontapp.com/reference/conversations#search-conversations). 
         * @summary List conversations
         * @param {string} [q] [Search query object](https://dev.frontapp.com/docs/query-object-q) with a property &#x60;statuses&#x60;, whose value should be a list of conversation statuses (&#x60;assigned&#x60;, &#x60;unassigned&#x60;, &#x60;archived&#x60;, or &#x60;deleted&#x60;).
         * @param {number} [limit] Max number of results per [page](https://dev.frontapp.com/docs/pagination)
         * @param {string} [pageToken] Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
         * @param {string} [sortBy] Field used to sort the conversations. Only supports &#x60;date&#x60;.
         * @param {'asc' | 'desc'} [sortOrder] Order by which results should be sorted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInReverseChronologicalOrder: async (q?: string, limit?: number, pageToken?: string, sortBy?: string, sortOrder?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the inboxes in which a conversation is listed.
         * @summary List conversation inboxes
         * @param {string} conversationId The conversation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInboxes: async (conversationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('listInboxes', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}/inboxes`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}/inboxes',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the messages in a conversation in reverse chronological order (newest first).
         * @summary List conversation messages
         * @param {string} conversationId The conversation ID
         * @param {number} [limit] Max number of results per [page](https://dev.frontapp.com/docs/pagination)
         * @param {string} [pageToken] Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
         * @param {string} [sortBy] Field used to sort the messages. Only supports &#x60;created_at&#x60;.
         * @param {'asc' | 'desc'} [sortOrder] Order by which results should be sorted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessagesInReverseChronologicalOrder: async (conversationId: string, limit?: number, pageToken?: string, sortBy?: string, sortOrder?: 'asc' | 'desc', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('listMessagesInReverseChronologicalOrder', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}/messages`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}/messages',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes teammates from the list of followers of a conversation.
         * @summary Delete conversation followers
         * @param {string} conversationId The conversation ID
         * @param {ConversationsRemoveFollowersRequest} [conversationsRemoveFollowersRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFollowers: async (conversationId: string, conversationsRemoveFollowersRequest?: ConversationsRemoveFollowersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('removeFollowers', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}/followers`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsRemoveFollowersRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}/followers',
                httpMethod: 'DELETE'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsRemoveFollowersRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes one or more links to a conversation
         * @summary Remove conversation links
         * @param {string} conversationId The conversation ID
         * @param {ConversationsRemoveLinksRequest} [conversationsRemoveLinksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeLinks: async (conversationId: string, conversationsRemoveLinksRequest?: ConversationsRemoveLinksRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('removeLinks', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}/links`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: conversationsRemoveLinksRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}/links',
                httpMethod: 'DELETE'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(conversationsRemoveLinksRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes one or more tags to a conversation
         * @summary Remove conversation tag
         * @param {string} conversationId The conversation ID
         * @param {TagIds} [tagIds] Tag IDs to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTag: async (conversationId: string, tagIds?: TagIds, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('removeTag', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}/tags`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: tagIds,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}/tags',
                httpMethod: 'DELETE'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(tagIds, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for conversations. Response will include a count of total matches and an array of conversations in descending order by last activity. See the [search syntax documentation](https://dev.frontapp.com/docs/search-1) for usage examples. **Note:** This endpoint is subject to [proportional rate limiting](https://dev.frontapp.com/docs/rate-limiting#additional-proportional-limiting) at 40% of your company\'s rate limit. 
         * @summary Search conversations
         * @param {string} query Search query string. See [Search](https://dev.frontapp.com/docs/search-1) topic for usage details.
         * @param {number} [limit] Max number of results per [page](https://dev.frontapp.com/docs/pagination)
         * @param {string} [pageToken] Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchByQuery: async (query: string, limit?: number, pageToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchByQuery', 'query', query)
            const localVarPath = `/conversations/search/{query}`
                .replace(`{${"query"}}`, encodeURIComponent(String(query !== undefined ? query : `-query-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/search/{query}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign or unassign a conversation.
         * @summary Update conversation assignee
         * @param {string} conversationId The conversation ID
         * @param {UpdateConversationAssignee} [updateConversationAssignee] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssignee: async (conversationId: string, updateConversationAssignee?: UpdateConversationAssignee, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('updateAssignee', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}/assignee`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: updateConversationAssignee,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}/assignee',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(updateConversationAssignee, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a conversation.
         * @summary Update conversation
         * @param {string} conversationId The conversation ID
         * @param {UpdateConversation} [updateConversation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationById: async (conversationId: string, updateConversation?: UpdateConversation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('updateConversationById', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: updateConversation,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(updateConversation, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Snooze or unsnooze a conversation for the provided user. For private conversations, reminders can only be created and edited through the API for teammates that own the conversation. For shared conversations, reminders created and edited through the API are shared for all teammates within the shared inbox(es) that the conversation belongs to. 
         * @summary Update conversation reminders
         * @param {string} conversationId The conversation ID
         * @param {UpdateConversationReminders} [updateConversationReminders] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReminders: async (conversationId: string, updateConversationReminders?: UpdateConversationReminders, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('updateReminders', 'conversationId', conversationId)
            const localVarPath = `/conversations/{conversation_id}/reminders`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId !== undefined ? conversationId : `-conversation_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: updateConversationReminders,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/conversations/{conversation_id}/reminders',
                httpMethod: 'PATCH'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(updateConversationReminders, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversationsApi - functional programming interface
 * @export
 */
export const ConversationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConversationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds teammates to the list of followers of a conversation.
         * @summary Add conversation followers
         * @param {ConversationsApiAddFollowersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addFollowers(requestParameters: ConversationsApiAddFollowersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const conversationsAddFollowersRequest: ConversationsAddFollowersRequest = {
                teammate_ids: requestParameters.teammate_ids
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addFollowers(requestParameters.conversationId, conversationsAddFollowersRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds one or more links to a conversation
         * @summary Add conversation link
         * @param {ConversationsApiAddLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addLink(requestParameters: ConversationsApiAddLinkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const conversationsAddLinkRequest: ConversationsAddLinkRequest = {
                link_ids: requestParameters.link_ids,
                link_external_urls: requestParameters.link_external_urls
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addLink(requestParameters.conversationId, conversationsAddLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds one or more tags to a conversation
         * @summary Add conversation tag
         * @param {ConversationsApiAddTagsToConversationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTagsToConversation(requestParameters: ConversationsApiAddTagsToConversationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const tagIds: TagIds = {
                tag_ids: requestParameters.tag_ids
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTagsToConversation(requestParameters.conversationId, tagIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new [conversation](https://dev.frontapp.com/reference/conversations#creating-a-new-conversation) that only supports comments (known as discussions in Front). If you want to create a conversation that supports messages, use the [Create message](https://dev.frontapp.com/reference/post_channels-channel-id-messages) endpoint. If you want to add a comment to an existing conversation, use the [Add comment](https://dev.frontapp.com/reference/post_conversations-conversation-id-comments) endpoint.
         * @summary Create discussion conversation
         * @param {ConversationsApiCreateDiscussionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiscussion(requestParameters: ConversationsApiCreateDiscussionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const createConversation: CreateConversation = {
                type: requestParameters.type,
                inbox_id: requestParameters.inbox_id,
                teammate_ids: requestParameters.teammate_ids,
                subject: requestParameters.subject,
                comment: requestParameters.comment
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiscussion(createConversation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch a conversation. 
         * @summary Get conversation
         * @param {ConversationsApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(requestParameters: ConversationsApiGetByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(requestParameters.conversationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the events that occured for a conversation in reverse chronological order (newest first). The order will respect your company\'s [bump settings](https://help.front.com/t/y729th/customize-when-conversations-bump-up), which determine when conversations bump to the top.
         * @summary List conversation events
         * @param {ConversationsApiListEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEvents(requestParameters: ConversationsApiListEventsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsListEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEvents(requestParameters.conversationId, requestParameters.limit, requestParameters.pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the teammates following a conversation.
         * @summary List conversation followers
         * @param {ConversationsApiListFollowersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFollowers(requestParameters: ConversationsApiListFollowersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentsListMentionedTeammatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFollowers(requestParameters.conversationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the conversations in the company in reverse chronological order (most recently updated first). The order will respect your company\'s [bump settings](https://help.front.com/t/y729th/customize-when-conversations-bump-up), which determine when conversations bump to the top. For more advanced filtering, see the [search endpoint](https://dev.frontapp.com/reference/conversations#search-conversations). 
         * @summary List conversations
         * @param {ConversationsApiListInReverseChronologicalOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInReverseChronologicalOrder(requestParameters: ConversationsApiListInReverseChronologicalOrderRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContactsListConversationsReverseChronologicalOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInReverseChronologicalOrder(requestParameters.q, requestParameters.limit, requestParameters.pageToken, requestParameters.sortBy, requestParameters.sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the inboxes in which a conversation is listed.
         * @summary List conversation inboxes
         * @param {ConversationsApiListInboxesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInboxes(requestParameters: ConversationsApiListInboxesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsListInboxesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInboxes(requestParameters.conversationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the messages in a conversation in reverse chronological order (newest first).
         * @summary List conversation messages
         * @param {ConversationsApiListMessagesInReverseChronologicalOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMessagesInReverseChronologicalOrder(requestParameters: ConversationsApiListMessagesInReverseChronologicalOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DraftsListConversationDraftsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMessagesInReverseChronologicalOrder(requestParameters.conversationId, requestParameters.limit, requestParameters.pageToken, requestParameters.sortBy, requestParameters.sortOrder, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes teammates from the list of followers of a conversation.
         * @summary Delete conversation followers
         * @param {ConversationsApiRemoveFollowersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFollowers(requestParameters: ConversationsApiRemoveFollowersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const conversationsRemoveFollowersRequest: ConversationsRemoveFollowersRequest = {
                teammate_ids: requestParameters.teammate_ids
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFollowers(requestParameters.conversationId, conversationsRemoveFollowersRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes one or more links to a conversation
         * @summary Remove conversation links
         * @param {ConversationsApiRemoveLinksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeLinks(requestParameters: ConversationsApiRemoveLinksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const conversationsRemoveLinksRequest: ConversationsRemoveLinksRequest = {
                link_ids: requestParameters.link_ids
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeLinks(requestParameters.conversationId, conversationsRemoveLinksRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes one or more tags to a conversation
         * @summary Remove conversation tag
         * @param {ConversationsApiRemoveTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTag(requestParameters: ConversationsApiRemoveTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const tagIds: TagIds = {
                tag_ids: requestParameters.tag_ids
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTag(requestParameters.conversationId, tagIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search for conversations. Response will include a count of total matches and an array of conversations in descending order by last activity. See the [search syntax documentation](https://dev.frontapp.com/docs/search-1) for usage examples. **Note:** This endpoint is subject to [proportional rate limiting](https://dev.frontapp.com/docs/rate-limiting#additional-proportional-limiting) at 40% of your company\'s rate limit. 
         * @summary Search conversations
         * @param {ConversationsApiSearchByQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchByQuery(requestParameters: ConversationsApiSearchByQueryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationsSearchByQueryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchByQuery(requestParameters.query, requestParameters.limit, requestParameters.pageToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Assign or unassign a conversation.
         * @summary Update conversation assignee
         * @param {ConversationsApiUpdateAssigneeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAssignee(requestParameters: ConversationsApiUpdateAssigneeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const updateConversationAssignee: UpdateConversationAssignee = {
                assignee_id: requestParameters.assignee_id
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAssignee(requestParameters.conversationId, updateConversationAssignee, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a conversation.
         * @summary Update conversation
         * @param {ConversationsApiUpdateConversationByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConversationById(requestParameters: ConversationsApiUpdateConversationByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const updateConversation: UpdateConversation = {
                assignee_id: requestParameters.assignee_id,
                inbox_id: requestParameters.inbox_id,
                status: requestParameters.status,
                tag_ids: requestParameters.tag_ids,
                custom_fields: requestParameters.custom_fields
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConversationById(requestParameters.conversationId, updateConversation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Snooze or unsnooze a conversation for the provided user. For private conversations, reminders can only be created and edited through the API for teammates that own the conversation. For shared conversations, reminders created and edited through the API are shared for all teammates within the shared inbox(es) that the conversation belongs to. 
         * @summary Update conversation reminders
         * @param {ConversationsApiUpdateRemindersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReminders(requestParameters: ConversationsApiUpdateRemindersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const updateConversationReminders: UpdateConversationReminders = {
                teammate_id: requestParameters.teammate_id,
                scheduled_at: requestParameters.scheduled_at
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReminders(requestParameters.conversationId, updateConversationReminders, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConversationsApi - factory interface
 * @export
 */
export const ConversationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConversationsApiFp(configuration)
    return {
        /**
         * Adds teammates to the list of followers of a conversation.
         * @summary Add conversation followers
         * @param {ConversationsApiAddFollowersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFollowers(requestParameters: ConversationsApiAddFollowersRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addFollowers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds one or more links to a conversation
         * @summary Add conversation link
         * @param {ConversationsApiAddLinkRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLink(requestParameters: ConversationsApiAddLinkRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addLink(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds one or more tags to a conversation
         * @summary Add conversation tag
         * @param {ConversationsApiAddTagsToConversationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagsToConversation(requestParameters: ConversationsApiAddTagsToConversationRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addTagsToConversation(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new [conversation](https://dev.frontapp.com/reference/conversations#creating-a-new-conversation) that only supports comments (known as discussions in Front). If you want to create a conversation that supports messages, use the [Create message](https://dev.frontapp.com/reference/post_channels-channel-id-messages) endpoint. If you want to add a comment to an existing conversation, use the [Add comment](https://dev.frontapp.com/reference/post_conversations-conversation-id-comments) endpoint.
         * @summary Create discussion conversation
         * @param {ConversationsApiCreateDiscussionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscussion(requestParameters: ConversationsApiCreateDiscussionRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createDiscussion(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a conversation. 
         * @summary Get conversation
         * @param {ConversationsApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(requestParameters: ConversationsApiGetByIdRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List the events that occured for a conversation in reverse chronological order (newest first). The order will respect your company\'s [bump settings](https://help.front.com/t/y729th/customize-when-conversations-bump-up), which determine when conversations bump to the top.
         * @summary List conversation events
         * @param {ConversationsApiListEventsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(requestParameters: ConversationsApiListEventsRequest, options?: AxiosRequestConfig): AxiosPromise<ConversationsListEventsResponse> {
            return localVarFp.listEvents(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List the teammates following a conversation.
         * @summary List conversation followers
         * @param {ConversationsApiListFollowersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFollowers(requestParameters: ConversationsApiListFollowersRequest, options?: AxiosRequestConfig): AxiosPromise<CommentsListMentionedTeammatesResponse> {
            return localVarFp.listFollowers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List the conversations in the company in reverse chronological order (most recently updated first). The order will respect your company\'s [bump settings](https://help.front.com/t/y729th/customize-when-conversations-bump-up), which determine when conversations bump to the top. For more advanced filtering, see the [search endpoint](https://dev.frontapp.com/reference/conversations#search-conversations). 
         * @summary List conversations
         * @param {ConversationsApiListInReverseChronologicalOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInReverseChronologicalOrder(requestParameters: ConversationsApiListInReverseChronologicalOrderRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ContactsListConversationsReverseChronologicalOrderResponse> {
            return localVarFp.listInReverseChronologicalOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List the inboxes in which a conversation is listed.
         * @summary List conversation inboxes
         * @param {ConversationsApiListInboxesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInboxes(requestParameters: ConversationsApiListInboxesRequest, options?: AxiosRequestConfig): AxiosPromise<ConversationsListInboxesResponse> {
            return localVarFp.listInboxes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * List the messages in a conversation in reverse chronological order (newest first).
         * @summary List conversation messages
         * @param {ConversationsApiListMessagesInReverseChronologicalOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMessagesInReverseChronologicalOrder(requestParameters: ConversationsApiListMessagesInReverseChronologicalOrderRequest, options?: AxiosRequestConfig): AxiosPromise<DraftsListConversationDraftsResponse> {
            return localVarFp.listMessagesInReverseChronologicalOrder(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes teammates from the list of followers of a conversation.
         * @summary Delete conversation followers
         * @param {ConversationsApiRemoveFollowersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFollowers(requestParameters: ConversationsApiRemoveFollowersRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeFollowers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes one or more links to a conversation
         * @summary Remove conversation links
         * @param {ConversationsApiRemoveLinksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeLinks(requestParameters: ConversationsApiRemoveLinksRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeLinks(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes one or more tags to a conversation
         * @summary Remove conversation tag
         * @param {ConversationsApiRemoveTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTag(requestParameters: ConversationsApiRemoveTagRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeTag(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for conversations. Response will include a count of total matches and an array of conversations in descending order by last activity. See the [search syntax documentation](https://dev.frontapp.com/docs/search-1) for usage examples. **Note:** This endpoint is subject to [proportional rate limiting](https://dev.frontapp.com/docs/rate-limiting#additional-proportional-limiting) at 40% of your company\'s rate limit. 
         * @summary Search conversations
         * @param {ConversationsApiSearchByQueryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchByQuery(requestParameters: ConversationsApiSearchByQueryRequest, options?: AxiosRequestConfig): AxiosPromise<ConversationsSearchByQueryResponse> {
            return localVarFp.searchByQuery(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign or unassign a conversation.
         * @summary Update conversation assignee
         * @param {ConversationsApiUpdateAssigneeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssignee(requestParameters: ConversationsApiUpdateAssigneeRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateAssignee(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a conversation.
         * @summary Update conversation
         * @param {ConversationsApiUpdateConversationByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationById(requestParameters: ConversationsApiUpdateConversationByIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateConversationById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Snooze or unsnooze a conversation for the provided user. For private conversations, reminders can only be created and edited through the API for teammates that own the conversation. For shared conversations, reminders created and edited through the API are shared for all teammates within the shared inbox(es) that the conversation belongs to. 
         * @summary Update conversation reminders
         * @param {ConversationsApiUpdateRemindersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReminders(requestParameters: ConversationsApiUpdateRemindersRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateReminders(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addFollowers operation in ConversationsApi.
 * @export
 * @interface ConversationsApiAddFollowersRequest
 */
export type ConversationsApiAddFollowersRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof ConversationsApiAddFollowers
    */
    readonly conversationId: string
    
} & ConversationsAddFollowersRequest

/**
 * Request parameters for addLink operation in ConversationsApi.
 * @export
 * @interface ConversationsApiAddLinkRequest
 */
export type ConversationsApiAddLinkRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof ConversationsApiAddLink
    */
    readonly conversationId: string
    
} & ConversationsAddLinkRequest

/**
 * Request parameters for addTagsToConversation operation in ConversationsApi.
 * @export
 * @interface ConversationsApiAddTagsToConversationRequest
 */
export type ConversationsApiAddTagsToConversationRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof ConversationsApiAddTagsToConversation
    */
    readonly conversationId: string
    
} & TagIds

/**
 * Request parameters for createDiscussion operation in ConversationsApi.
 * @export
 * @interface ConversationsApiCreateDiscussionRequest
 */
export type ConversationsApiCreateDiscussionRequest = {
    
} & CreateConversation

/**
 * Request parameters for getById operation in ConversationsApi.
 * @export
 * @interface ConversationsApiGetByIdRequest
 */
export type ConversationsApiGetByIdRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof ConversationsApiGetById
    */
    readonly conversationId: string
    
}

/**
 * Request parameters for listEvents operation in ConversationsApi.
 * @export
 * @interface ConversationsApiListEventsRequest
 */
export type ConversationsApiListEventsRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof ConversationsApiListEvents
    */
    readonly conversationId: string
    
    /**
    * Max number of results per [page](https://dev.frontapp.com/docs/pagination)
    * @type {number}
    * @memberof ConversationsApiListEvents
    */
    readonly limit?: number
    
    /**
    * Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
    * @type {string}
    * @memberof ConversationsApiListEvents
    */
    readonly pageToken?: string
    
}

/**
 * Request parameters for listFollowers operation in ConversationsApi.
 * @export
 * @interface ConversationsApiListFollowersRequest
 */
export type ConversationsApiListFollowersRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof ConversationsApiListFollowers
    */
    readonly conversationId: string
    
}

/**
 * Request parameters for listInReverseChronologicalOrder operation in ConversationsApi.
 * @export
 * @interface ConversationsApiListInReverseChronologicalOrderRequest
 */
export type ConversationsApiListInReverseChronologicalOrderRequest = {
    
    /**
    * [Search query object](https://dev.frontapp.com/docs/query-object-q) with a property `statuses`, whose value should be a list of conversation statuses (`assigned`, `unassigned`, `archived`, or `deleted`).
    * @type {string}
    * @memberof ConversationsApiListInReverseChronologicalOrder
    */
    readonly q?: string
    
    /**
    * Max number of results per [page](https://dev.frontapp.com/docs/pagination)
    * @type {number}
    * @memberof ConversationsApiListInReverseChronologicalOrder
    */
    readonly limit?: number
    
    /**
    * Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
    * @type {string}
    * @memberof ConversationsApiListInReverseChronologicalOrder
    */
    readonly pageToken?: string
    
    /**
    * Field used to sort the conversations. Only supports `date`.
    * @type {string}
    * @memberof ConversationsApiListInReverseChronologicalOrder
    */
    readonly sortBy?: string
    
    /**
    * Order by which results should be sorted
    * @type {'asc' | 'desc'}
    * @memberof ConversationsApiListInReverseChronologicalOrder
    */
    readonly sortOrder?: 'asc' | 'desc'
    
}

/**
 * Request parameters for listInboxes operation in ConversationsApi.
 * @export
 * @interface ConversationsApiListInboxesRequest
 */
export type ConversationsApiListInboxesRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof ConversationsApiListInboxes
    */
    readonly conversationId: string
    
}

/**
 * Request parameters for listMessagesInReverseChronologicalOrder operation in ConversationsApi.
 * @export
 * @interface ConversationsApiListMessagesInReverseChronologicalOrderRequest
 */
export type ConversationsApiListMessagesInReverseChronologicalOrderRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof ConversationsApiListMessagesInReverseChronologicalOrder
    */
    readonly conversationId: string
    
    /**
    * Max number of results per [page](https://dev.frontapp.com/docs/pagination)
    * @type {number}
    * @memberof ConversationsApiListMessagesInReverseChronologicalOrder
    */
    readonly limit?: number
    
    /**
    * Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
    * @type {string}
    * @memberof ConversationsApiListMessagesInReverseChronologicalOrder
    */
    readonly pageToken?: string
    
    /**
    * Field used to sort the messages. Only supports `created_at`.
    * @type {string}
    * @memberof ConversationsApiListMessagesInReverseChronologicalOrder
    */
    readonly sortBy?: string
    
    /**
    * Order by which results should be sorted
    * @type {'asc' | 'desc'}
    * @memberof ConversationsApiListMessagesInReverseChronologicalOrder
    */
    readonly sortOrder?: 'asc' | 'desc'
    
}

/**
 * Request parameters for removeFollowers operation in ConversationsApi.
 * @export
 * @interface ConversationsApiRemoveFollowersRequest
 */
export type ConversationsApiRemoveFollowersRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof ConversationsApiRemoveFollowers
    */
    readonly conversationId: string
    
} & ConversationsRemoveFollowersRequest

/**
 * Request parameters for removeLinks operation in ConversationsApi.
 * @export
 * @interface ConversationsApiRemoveLinksRequest
 */
export type ConversationsApiRemoveLinksRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof ConversationsApiRemoveLinks
    */
    readonly conversationId: string
    
} & ConversationsRemoveLinksRequest

/**
 * Request parameters for removeTag operation in ConversationsApi.
 * @export
 * @interface ConversationsApiRemoveTagRequest
 */
export type ConversationsApiRemoveTagRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof ConversationsApiRemoveTag
    */
    readonly conversationId: string
    
} & TagIds

/**
 * Request parameters for searchByQuery operation in ConversationsApi.
 * @export
 * @interface ConversationsApiSearchByQueryRequest
 */
export type ConversationsApiSearchByQueryRequest = {
    
    /**
    * Search query string. See [Search](https://dev.frontapp.com/docs/search-1) topic for usage details.
    * @type {string}
    * @memberof ConversationsApiSearchByQuery
    */
    readonly query: string
    
    /**
    * Max number of results per [page](https://dev.frontapp.com/docs/pagination)
    * @type {number}
    * @memberof ConversationsApiSearchByQuery
    */
    readonly limit?: number
    
    /**
    * Token to use to request the [next page](https://dev.frontapp.com/docs/pagination)
    * @type {string}
    * @memberof ConversationsApiSearchByQuery
    */
    readonly pageToken?: string
    
}

/**
 * Request parameters for updateAssignee operation in ConversationsApi.
 * @export
 * @interface ConversationsApiUpdateAssigneeRequest
 */
export type ConversationsApiUpdateAssigneeRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof ConversationsApiUpdateAssignee
    */
    readonly conversationId: string
    
} & UpdateConversationAssignee

/**
 * Request parameters for updateConversationById operation in ConversationsApi.
 * @export
 * @interface ConversationsApiUpdateConversationByIdRequest
 */
export type ConversationsApiUpdateConversationByIdRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof ConversationsApiUpdateConversationById
    */
    readonly conversationId: string
    
} & UpdateConversation

/**
 * Request parameters for updateReminders operation in ConversationsApi.
 * @export
 * @interface ConversationsApiUpdateRemindersRequest
 */
export type ConversationsApiUpdateRemindersRequest = {
    
    /**
    * The conversation ID
    * @type {string}
    * @memberof ConversationsApiUpdateReminders
    */
    readonly conversationId: string
    
} & UpdateConversationReminders

/**
 * ConversationsApiGenerated - object-oriented interface
 * @export
 * @class ConversationsApiGenerated
 * @extends {BaseAPI}
 */
export class ConversationsApiGenerated extends BaseAPI {
    /**
     * Adds teammates to the list of followers of a conversation.
     * @summary Add conversation followers
     * @param {ConversationsApiAddFollowersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public addFollowers(requestParameters: ConversationsApiAddFollowersRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).addFollowers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds one or more links to a conversation
     * @summary Add conversation link
     * @param {ConversationsApiAddLinkRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public addLink(requestParameters: ConversationsApiAddLinkRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).addLink(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds one or more tags to a conversation
     * @summary Add conversation tag
     * @param {ConversationsApiAddTagsToConversationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public addTagsToConversation(requestParameters: ConversationsApiAddTagsToConversationRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).addTagsToConversation(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new [conversation](https://dev.frontapp.com/reference/conversations#creating-a-new-conversation) that only supports comments (known as discussions in Front). If you want to create a conversation that supports messages, use the [Create message](https://dev.frontapp.com/reference/post_channels-channel-id-messages) endpoint. If you want to add a comment to an existing conversation, use the [Add comment](https://dev.frontapp.com/reference/post_conversations-conversation-id-comments) endpoint.
     * @summary Create discussion conversation
     * @param {ConversationsApiCreateDiscussionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public createDiscussion(requestParameters: ConversationsApiCreateDiscussionRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).createDiscussion(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a conversation. 
     * @summary Get conversation
     * @param {ConversationsApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public getById(requestParameters: ConversationsApiGetByIdRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).getById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the events that occured for a conversation in reverse chronological order (newest first). The order will respect your company\'s [bump settings](https://help.front.com/t/y729th/customize-when-conversations-bump-up), which determine when conversations bump to the top.
     * @summary List conversation events
     * @param {ConversationsApiListEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public listEvents(requestParameters: ConversationsApiListEventsRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).listEvents(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the teammates following a conversation.
     * @summary List conversation followers
     * @param {ConversationsApiListFollowersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public listFollowers(requestParameters: ConversationsApiListFollowersRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).listFollowers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the conversations in the company in reverse chronological order (most recently updated first). The order will respect your company\'s [bump settings](https://help.front.com/t/y729th/customize-when-conversations-bump-up), which determine when conversations bump to the top. For more advanced filtering, see the [search endpoint](https://dev.frontapp.com/reference/conversations#search-conversations). 
     * @summary List conversations
     * @param {ConversationsApiListInReverseChronologicalOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public listInReverseChronologicalOrder(requestParameters: ConversationsApiListInReverseChronologicalOrderRequest = {}, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).listInReverseChronologicalOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the inboxes in which a conversation is listed.
     * @summary List conversation inboxes
     * @param {ConversationsApiListInboxesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public listInboxes(requestParameters: ConversationsApiListInboxesRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).listInboxes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the messages in a conversation in reverse chronological order (newest first).
     * @summary List conversation messages
     * @param {ConversationsApiListMessagesInReverseChronologicalOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public listMessagesInReverseChronologicalOrder(requestParameters: ConversationsApiListMessagesInReverseChronologicalOrderRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).listMessagesInReverseChronologicalOrder(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes teammates from the list of followers of a conversation.
     * @summary Delete conversation followers
     * @param {ConversationsApiRemoveFollowersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public removeFollowers(requestParameters: ConversationsApiRemoveFollowersRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).removeFollowers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes one or more links to a conversation
     * @summary Remove conversation links
     * @param {ConversationsApiRemoveLinksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public removeLinks(requestParameters: ConversationsApiRemoveLinksRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).removeLinks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes one or more tags to a conversation
     * @summary Remove conversation tag
     * @param {ConversationsApiRemoveTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public removeTag(requestParameters: ConversationsApiRemoveTagRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).removeTag(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for conversations. Response will include a count of total matches and an array of conversations in descending order by last activity. See the [search syntax documentation](https://dev.frontapp.com/docs/search-1) for usage examples. **Note:** This endpoint is subject to [proportional rate limiting](https://dev.frontapp.com/docs/rate-limiting#additional-proportional-limiting) at 40% of your company\'s rate limit. 
     * @summary Search conversations
     * @param {ConversationsApiSearchByQueryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public searchByQuery(requestParameters: ConversationsApiSearchByQueryRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).searchByQuery(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign or unassign a conversation.
     * @summary Update conversation assignee
     * @param {ConversationsApiUpdateAssigneeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public updateAssignee(requestParameters: ConversationsApiUpdateAssigneeRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).updateAssignee(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a conversation.
     * @summary Update conversation
     * @param {ConversationsApiUpdateConversationByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public updateConversationById(requestParameters: ConversationsApiUpdateConversationByIdRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).updateConversationById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Snooze or unsnooze a conversation for the provided user. For private conversations, reminders can only be created and edited through the API for teammates that own the conversation. For shared conversations, reminders created and edited through the API are shared for all teammates within the shared inbox(es) that the conversation belongs to. 
     * @summary Update conversation reminders
     * @param {ConversationsApiUpdateRemindersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversationsApiGenerated
     */
    public updateReminders(requestParameters: ConversationsApiUpdateRemindersRequest, options?: AxiosRequestConfig) {
        return ConversationsApiFp(this.configuration).updateReminders(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
